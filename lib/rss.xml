<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[ML-Course]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>ML-Course</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 12 Oct 2024 21:57:46 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 12 Oct 2024 21:57:45 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Sprawdzenie danych]]></title><description><![CDATA[ 
 <br><br>Pierwszym co należy zrobić przed przystąpieniem do uczenia implementacji algorytmów uczenia maszynowego jest przejrzenie datasetu. Korzystając z poznanych wcześniej bibliotek możemy użyć następujących komend:<br>
<br>sprawdzenie liczby brakujących wartości w poszczególnych kolumnach:
<br>print(pandas_dataframe.isnull().sum())
Copy<br>
<br>obliczenie korelacji pomiędzy poszczególnymi kolumnami i wyświetlenie ich w formie macierzy korelacji:
<br># Wyliczenie macierzy korelacji
corr = pandas_dataframe.corr()

# Przygotowanie wykresu i wyświetlenie go (wymaga importowania seaborn i matplotlib)
plt.figure()
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")

plt.title('Correlation Matrix')
plt.show()
Copy<br>
<br>sprawdzić jakie unikalne wartości przyjmują dane w określonej kolumnie:
<br>pandas_dataframe['column_name'].unique()
Copy<br>
<br>wyświetlić dane numeryczne w formie histogramu:
<br>pandas_dataframe['column_name'].plot.hist(bins=5, color='red', edgecolor='black')
Copy<br><br>Wartości odstające, zwane również outliers, to wartości, które znacznie różnią się od reszty danych. W rezultacie mogą one niekorzystnie wpływać na wyniki analizy danych i modele uczenia maszynowego poprzez:<br>
<br>znaczne wpływanie na średnią, wariancję i inne statystyki opisowe,
<br>wprowadzanie szumu do modeli,
<br>prowadzenie do błędnych wniosków z analizy danych.
<br>W jaki sposób można sobie poradzić, jeżeli w danych występują wartości odstające:<br>
<br>usunięcie outlierów (np. jeżeli wynikają z błędu pomiaru lub wpisania danych i nie da się ich przybliżyć do reszty danych),
<br>winsoryzacja - zamiana wartości odstających na wartości graniczne pewnego przedziału (np. na wartości 95 percentyla),
<br>zamiana wartości odstających medianą (dzięki temu mniej wpływają na rozkład),
<br>wykorzystać normalizację, standaryzację lub podział danych na przedziały (o tym na dalszych podstronach).
<br><br>Najprostszą metodą identyfikacji wartości odstających jest użycie reguły rozstępu międzykwartylowego (IQR)<a data-footref="1" href="about:blank#fn-1-ca90d9ed965a22be" class="footnote-link" target="_self" rel="noopener">[1]</a>.<br>
<br>IQR (Interquartile Range): Różnica między trzecim kwartylem (75 percentyl) a pierwszym kwartylem (25 percentyl).
<br>Outliery są wartościami, które są poniżej  lub powyżej .
<br>Implementacja identyfikacji wartości odstających i winsoryzacji oraz filtrowania znajduje się poniżej:<br>import pandas as pd
import numpy as np

# Utworzenie dataframe
data = {'Wartość': [10, 12, 14, 15, 100, 13, 14, 16, 12, 13, 11, 110]}
df = pd.DataFrame(data)

# 1. Obliczenie Q1 (pierwszego kwartylu) i Q3 (trzeciego kwartylu)
Q1 = df['Wartość'].quantile(0.25)
Q3 = df['Wartość'].quantile(0.75)
IQR = Q3 - Q1  # Rozstęp międzykwartylowy

# 2. Definiowanie granic dla wartości odstających
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# 3. Usunięcie danych odstających
df_no_outliers = df[(df['Wartość'] &gt;= lower_bound) &amp; (df['Wartość'] &lt;= 
		upper_bound)]

# 4. Winsoryzacja - zastępowanie outlierów wartościami granicznymi 
df_winsorized = df.copy() 
df_winsorized['Wartość'] = np.where(df_winsorized['Wartość'] &gt; upper_bound, 
		upper_bound, np.where(df_winsorized['Wartość'] &lt; lower_bound, 
		lower_bound, df_winsorized['Wartość']))
Copy<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Brakujące dane" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\brakujące-dane.html" class="internal-link" target="_self" rel="noopener">Brakujące dane</a>) lub kliknij <a data-tooltip-position="top" aria-label="Przygotowanie danych i inżynieria cech" data-href="Przygotowanie danych i inżynieria cech" href="tematy\przygotowanie-danych-i-inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.<br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Interquartile_range" target="_blank">https://en.wikipedia.org/wiki/Interquartile_range</a><a href="about:blank#fnref-1-ca90d9ed965a22be" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\files-przygotowanie-danych-i-inżynieria-cech\co-zrobić-po-otrzymaniu-zbioru-danych.html</link><guid isPermaLink="false">Tematy/Files Przygotowanie danych i inżynieria cech/Co zrobić po otrzymaniu zbioru danych.md</guid><pubDate>Sat, 12 Oct 2024 21:55:29 GMT</pubDate></item><item><title><![CDATA[Kodowanie kolumn]]></title><description><![CDATA[ 
 <br><br>W przypadku kolumn, w którym przechowywane są dane tekstowe, kluczowym krokiem jest zamiana tych wartości na wartości numeryczne przed użyciem w modelu uczenia maszynowego. W zależności od charakteru danych można zastosować różne metody:<br>
<br>kodowanie etykiet (label encoding) - polega na przypisaniu każdej unikalnej wartości tekstowej w kolumnie liczby całkowitej. Wadą może być jeżeli nie ma naturalnego porządku w kategoriach, bo model może zakładać, że wyższe liczby mają większe znaczenie.
<br>from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
df['column_name'] = le.fit_transform(df['column_name']) 
#dla zbioru testowego/walidacyjnego należy enkodera utworzonego na zbiorze treningowym (w tym przypadku df):
test_df['column_name'] = le.transform(test_df['column_name'])
Copy<br>
<br>one-hot encoding: tworzy osobne kolumny dla każdej unikalnej wartości tekstowej w kolumnie, a następnie przypisuje wartość 0 lub 1 w tych kolumnach, wskazując, czy dana obserwacja zawiera daną kategorię. Zaletą jest, że nie występuje wiele wartości, które mogłyby mylić model, ale wadą jest utworzenie wielu kolumn (co w przypadku rozbudowanych zbiorów danych może bardzo zwiększyć zapotrzebowanie na pamięć do przechowywania datasetu).
<br>df = pd.get_dummies(df, columns=['column_name'])
Copy<br>
<br>mapowanie wartości: ręczne przypisane liczby do wartości tekstowych, co bywa przydatne w przypadku danych z wyraźnym porządkiem logicznym.
<br>mapping = {'val_1': 1, 'val_2': 2, 'val_3': 3} 
df['column_name'] = df['column_name'].map(mapping)
Copy<br>Przykład jak wygląda zakodowanie kolumny ocena, w której przechowywane są wartości: niska, średnia i wysoka:<br>
<br>Podstawowa kolumna:
<br><br>
<br>Zakodowana kolumna przy pomocy label encoding (wysoka -&gt; 0, niska -&gt; 1, średnia -&gt; 2)
<br><br>
<br>Wykorzystanie one-hot encoding:
<br><br>
<br>Wykorzystanie mapowania {'niska': 0, 'średnia': 1, 'wysoka': 2}:
<br><br><br>Data binning jest techniką wstępnej obróbki danych, która polega na grupowaniu ciągłych danych liczbowych w dyskretne przedziały lub "koszyki". W efekcie, zamiast mieć nieskończony zestaw możliwych wartości liczbowych, przekształcamy dane na określoną liczbę przedziałów, co ułatwia analizę i może poprawić działanie niektórych modeli uczenia maszynowego.<br>Zaletami jest uproszczenie interpretacji (na danych ciągłych może być trudność w analizie datasetu), obsługę nieliniowości, zmniejszenie wpływu szumu (po podziale na koszyki drobne fluktuacje mają mniejsze znaczenie, co pozwala zrozumieć ogólne trendy), oraz ułatwienie modelowania, bo część modeli (np. drzewa decyzyjne) mogą działać lepiej, kiedy dane zamiast być ciągłe to są podzielone na przedziały.<br>Wyróżnić można następujące rodzaje binningu:<br>
<br>podział na przedziały o równej szerokości (każdy przedział ma taką samą szerokość, ale liczba elementów w każdym koszyku może się różnić),
<br>podział na przedziały o równej liczebności (każdy przedział ma taką samą liczbę obserwacji, ale szerokość każdego przedziału zależy od rozkładu danych),
<br>podział na przedziały ze względu na dane i ich zastosowanie (np. kolumna wiek mogłaby zostać podzielona na 3 podzbiory 0-18, 18-65 i 65+).
<br>Przykład implementacji każdej z przedstawionych metod znajduje się poniżej:<br>import pandas as pd

# Przykładowy DataFrame z kolumną 'Wiek'
data_wiek = {'Wiek': [5, 17, 25, 45, 67, 72, 15, 60, 19, 84]}
df_wiek = pd.DataFrame(data_wiek)

# Przedziały o równej szerokości
df_wiek['Wiek_equal_width'] = pd.cut(df_wiek['Wiek'], bins=3, labels=[0, 1, 2])

# Przedziały o równej liczebności
df_wiek['Wiek_equal_freq'] = pd.qcut(df_wiek['Wiek'], q=3, labels=[0, 1, 2])

# Na podstawie własnych reguł na koszyki 0-18, 18-65 i 65+
bins_business = [0, 18, 65, float('inf')]
labels_business = [0, 1, 2]
df_wiek['Wiek_own_rules'] = pd.cut(df_wiek['Wiek'], bins=bins_business, labels=labels_business)
Copy<br><br>Czasami w procesie analizy danych nie wystarczy po prostu użyć surowych wartości — warto pomyśleć o tym, jak możemy z istniejących danych wyciągnąć dodatkowe informacje lub wyliczyć bardziej użyteczne cechy, które mogą mieć większe znaczenie dla modelu lub analizy. Tego rodzaju proces, zwany feature engineering, może znacznie poprawić wyniki modelu i jakość wniosków. Oto kilka przykładów, jak można wykorzystać istniejące dane do wyciągania dodatkowych informacji:<br>
<br>wyliczenie wartości średniej: np. posiadając liczbę transakcji sklepu w ciągu miesiąca i jaka była suma transakcji w miesiącu można obliczyć średnią, co może mieć znaczenie przy podawaniu danych do modelu,
<br>obliczenie procentów/proporcji: np. wyliczenie jaki procent transakcji sklepu to zakupy pieczywa,
<br>sumowanie wartości z kilku kolumn,
<br>wyciąganie dodatkowych informacji, np. kolumna przechowująca wartości binarne, które powstają przez sprawdzenie warunku "Czy dany sklep ma minimum 15 transakcji w miesiącu i średnią wartość transakcji powyżej 50pln?",
<br>wyciąganie cech z kolumn tekstowych, np. długość tekstu, ilość słów, ilość hasztagów, występowanie poszczególnych słów, etc.
<br><br>Kliknij <a data-tooltip-position="top" aria-label="Przygotowanie danych i inżynieria cech" data-href="Przygotowanie danych i inżynieria cech" href="tematy\przygotowanie-danych-i-inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu. Możesz stamtąd przejść do wykonania zadań przygotowanych w Jupyter Notebook.]]></description><link>tematy\files-przygotowanie-danych-i-inżynieria-cech\inżynieria-cech.html</link><guid isPermaLink="false">Tematy/Files Przygotowanie danych i inżynieria cech/Inżynieria cech.md</guid><pubDate>Sat, 12 Oct 2024 21:25:26 GMT</pubDate></item><item><title><![CDATA[Normalizacja]]></title><description><![CDATA[ 
 <br><br>Normalizacja polega na przekształceniu danych tak, aby mieściły się w określonym zakresie (zwykle od 0 do 1). Jest to przydatne, gdy dane mają bardzo różne skale, a chcemy by na wejściu algorytmu wartości mieściły się w określonym przedziale.<br>Wzór na normalizację:<br><br>gdzie:<br>
<br> to oryginalna wartość,
<br>​ to minimalna wartość w danym zbiorze,
<br> to maksymalna wartość w danym zbiorze.
<br>Przeprowadzenie standaryzacji w języku Python możliwe jest przy pomocy biblioteki Scikit-Learn<br>from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
df_normalized = scaler.fit_transform(df)  # Normalizacja całego DataFrame
df_normalized = pd.DataFrame(df_normalized, columns=df.columns)

Copy<br><br>Standaryzacja polega na przekształceniu danych tak, aby miały średnią równą 0 i odchylenie standardowe równe 1. Jest to przydatne, gdy chcemy, aby różne cechy miały porównywalny wpływ na model (niektóre algorytmy jak regresja liniowa czy SVM są bardzo wrażliwe na skalę danych). <br>Formuła standaryzacji:<br><br>gdzie:<br>
<br> to oryginalna wartość,
<br> to średnia wartość cechy,
<br> to odchylenie standardowe cechy (pierwiastek wariancji).
<br>Zastosowanie standaryzacji w języku Python możliwe jest przy pomocy biblioteki Scikit-Learn<br>from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
df_standardized = scaler.fit_transform(df)  # Standaryzacja całego DataFrame
df_standardized = pd.DataFrame(df_standardized, columns=df.columns)
Copy<br>
Należy pamiętać, że po podzieleniu datasetu na zbiór treningowy, walidacyjny i testowy należy wykorzystywać ten sam imputer i skalery dla wszystkich zbiorów. Oznacza to, że należy wykorzystać fit lub fit_transform przy zbiorze treningowym, a dla pozostałych wykorzystywać samo transform.
<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Inżynieria cech" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">Inżynieria cech</a>) lub kliknij <a data-tooltip-position="top" aria-label="Przygotowanie danych i inżynieria cech" data-href="Przygotowanie danych i inżynieria cech" href="tematy\przygotowanie-danych-i-inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.]]></description><link>tematy\files-przygotowanie-danych-i-inżynieria-cech\normalizacja-i-standaryzacja.html</link><guid isPermaLink="false">Tematy/Files Przygotowanie danych i inżynieria cech/Normalizacja i standaryzacja.md</guid><pubDate>Sat, 12 Oct 2024 21:55:35 GMT</pubDate></item><item><title><![CDATA[Uzupełnianie brakujących wartości]]></title><description><![CDATA[ 
 <br><br>Jeżeli brakuje danych - dana wartość może być pusta, ale może być wstawiona jakaś wartość domyślna (np. w kolumnie wzrost mogłyby być wpisane wartości 0, które od razu widać, że nie mają sensu) - można podjąć następujące kroki:<br>
<br>poddać się (to nie w naszym stylu),
<br>usunąć kolumnę - warto zrobić jeżeli w danej kolumnie brakuje wielu danych, których nie ma jak uzupełnić lub są to dane, które nie są użyteczne,
<br># Przykładowe dane z brakującymi wartościami
data = {'A': [1, 2, None, 4, 5],
        'B': [None, 2, 3, None, 5],
        'C': [1, None, None, 4, 5]}

# Tworzenie DataFrame
df = pd.DataFrame(data)

df_without_cols = df.drop(columns=['column_name_1', 'column_name_2'])
Copy<br>
<br>uzupełnić kolumnę przy pomocy określonej wartości (np. średniej wartości w danej kolumnie, najczęściej występującej wartości w danej kolumnie lub mediany wartości tej kolumny) lub wykorzystać regresję, aby na podstawie danych z innych kolumn uzupełnić te brakujące miejsca.
<br>from sklearn.impute import SimpleImputer

# Wykorzystamy DataFrame z poprzedniego fragmentu kodu
# Wypełnianie wartością średnią
imputer_mean = SimpleImputer(strategy='mean')
df_imputed_mean = pd.DataFrame(imputer_mean.fit_transform(df), columns=df.columns)

#Wypełnianie medianą
imputer_median = SimpleImputer(strategy='median') 
df_imputed_median = pd.DataFrame(imputer_median.fit_transform(df), columns=df.columns)

# Wypełnianie najczęstszą wartością
imputer_most_frequent = SimpleImputer(strategy='most_frequent') df_imputed_most_frequent = pd.DataFrame(imputer_most_frequent.fit_transform(df), columns=df.columns)

# Wypełnianie stałą wartością podaną przez użytkownika
imputer_constant = SimpleImputer(strategy='constant', fill_value=5) df_imputed_constant = pd.DataFrame(imputer_constant.fit_transform(df), columns=df.columns)

# Metody korzystające z regresji
from sklearn.experimental import enable_iterative_imputer 
from sklearn.impute import IterativeImputer, KNNImputer

# Wypenianie przy pomocy regresji wielokrotnej
iter_imputer = IterativeImputer()
df_iter_imputed = pd.DataFrame(iter_imputer.fit_transform(df), columns=df.columns)

# Wypełnianie za pomocą k-Najbliższych sąsiadów
knn_imputer = KNNImputer(n_neighbors=3)
df_knn_imputed = pd.DataFrame(knn_imputer.fit_transform(df), columns=df.columns)
Copy<br>
Należy pamiętać, że po podzieleniu datasetu na zbiór treningowy, walidacyjny i testowy należy wykorzystywać ten sam imputer i skalery dla wszystkich zbiorów. Oznacza to, że należy wykorzystać fit lub fit_transform przy zbiorze treningowym, a dla pozostałych wykorzystywać samo transform.
<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Normalizacja i standaryzacja" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\normalizacja-i-standaryzacja.html" class="internal-link" target="_self" rel="noopener">Normalizacja i standaryzacja</a>) lub kliknij <a data-tooltip-position="top" aria-label="Przygotowanie danych i inżynieria cech" data-href="Przygotowanie danych i inżynieria cech" href="tematy\przygotowanie-danych-i-inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.]]></description><link>tematy\files-przygotowanie-danych-i-inżynieria-cech\brakujące-dane.html</link><guid isPermaLink="false">Tematy/Files Przygotowanie danych i inżynieria cech/Brakujące dane.md</guid><pubDate>Sat, 12 Oct 2024 13:46:42 GMT</pubDate></item><item><title><![CDATA[Czym jest Scikit-learn]]></title><description><![CDATA[ 
 ]]></description><link>tematy\files-regresja-liniowa-(i-nie-tylko)\czym-jest-scikit-learn.html</link><guid isPermaLink="false">Tematy/Files Regresja liniowa (i nie tylko)/Czym jest Scikit-learn.md</guid><pubDate>Fri, 11 Oct 2024 20:35:08 GMT</pubDate></item><item><title><![CDATA[Przygotowanie danych i inżynieria cech]]></title><description><![CDATA[ 
 <br>Preprocessing danych to kluczowy krok w uczeniu maszynowym, który ma na celu poprawienie jakości i użyteczności danych. Dane rzeczywiste często są niekompletne, zawierają brakujące wartości, szumy, błędy lub nieprawidłowości, co negatywnie wpływa na działanie modeli (dane z tutoriali są zwykle idealnie przygotowane, a rzeczywiste zbiory danych są znacznie bardziej skomplikowane i wymagają starannej obróbki przed użyciem w modelach). Dlatego konieczne jest sprawdzenie i uzupełnienie braków, usunięcie błędów oraz ewentualne stworzenie nowych cech (feature engineering), które lepiej reprezentują ukryte zależności w danych. <br>Sam proces przygotowywania danych jest czasochłonny i wymaga kreatywności, więc w tej części naszego kursu postaramy się zobaczyć jakie są pomysły i główne działania, ale na każdym datasecie trzeba zastosować indywidualne podejście. <br><img alt="cleaning_data_meme.jpg" src="tematy\images\cleaning_data_meme.jpg"><br><br>
<br><a data-tooltip-position="top" aria-label="Co zrobić po otrzymaniu zbioru danych" data-href="Co zrobić po otrzymaniu zbioru danych" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\co-zrobić-po-otrzymaniu-zbioru-danych.html" class="internal-link" target="_self" rel="noopener">Co zrobić po otrzymaniu zbioru danych?</a>
<br><a data-href="Brakujące dane" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\brakujące-dane.html" class="internal-link" target="_self" rel="noopener">Brakujące dane</a>
<br><a data-href="Normalizacja i standaryzacja" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\normalizacja-i-standaryzacja.html" class="internal-link" target="_self" rel="noopener">Normalizacja i standaryzacja</a>
<br><a data-href="Inżynieria cech" href="tematy\files-przygotowanie-danych-i-inżynieria-cech\inżynieria-cech.html" class="internal-link" target="_self" rel="noopener">Inżynieria cech</a>
<br><br>Ćwiczenia dla tego tematu zostały zebrane <a data-tooltip-position="top" aria-label="https://github.com/" rel="noopener" class="external-link" href="https://github.com/" target="_blank">tutaj</a>.<br><br>Kliknij <a data-tooltip-position="top" aria-label="Index" data-href="Index" href="index.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej kursu.<br>* Podczas przygotowania opisów dla tego tematu, przy części zagadnień wykorzystane zostały narzędzia generatywnej sztucznej inteligencji.]]></description><link>tematy\przygotowanie-danych-i-inżynieria-cech.html</link><guid isPermaLink="false">Tematy/Przygotowanie danych i inżynieria cech.md</guid><pubDate>Sat, 12 Oct 2024 13:10:26 GMT</pubDate><enclosure url="tematy\images\cleaning_data_meme.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="tematy\images\cleaning_data_meme.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Czym jest regresja?]]></title><description><![CDATA[ 
 <br><br>Regresja służy do modelowania zależności między zmiennymi. Pozwala ona przewidzieć wartość jednej zmiennej (zależnej) na podstawie wartości innych zmiennych (niezależnych).<br>Prostym przykładem do wytłumaczenia jest przewidywanie ceny lub zarobków, które polegają na znalezieniu matematycznego wzoru służącego do wyliczenia wartości przy znanych zmiennych niezależnych. Dla ceny mieszkania mogą to być: metraż, ilość sypialni, wielkość ogrodu, lokalizacja, rok budowy budynku; natomiast dla zarobków może być to doświadczenie zawodowe, poziom wykształcenia, wiek oraz dodatkowe umiejętności.<br><img alt="linear_regression_meme.png" src="tematy\images\linear_regression_meme.png"><br>
Źródło: <a data-footref="xk" href="about:blank#fn-1-b5136e12ec7be2be" class="footnote-link" target="_self" rel="noopener">[1]</a><br>Z regresją można się też spotkać (często nieświadomie) podczas laboratoriów, np. z fizyki, gdy na podstawie pomiarów z eksperymentów należy wyliczyć wartość jakiegoś współczynnika (np. mając pomiar wychylenia w stopniach i napięcie z czujnika) lub gdy chcemy dodać wartości brakujących pomiarów. <br><img alt="extrapolating_meme.png" src="tematy\images\extrapolating_meme.png"><br>
Źródło: <a data-footref="xk2" href="about:blank#fn-2-b5136e12ec7be2be" class="footnote-link" target="_self" rel="noopener">[2]</a><br><br>
<br><a data-href="Rodzaje regresji" href="tematy\files-regresja-liniowa-(i-nie-tylko)\rodzaje-regresji.html" class="internal-link" target="_self" rel="noopener">Rodzaje regresji</a>
<br><a data-tooltip-position="top" aria-label="Czym jest Scikit-learn" data-href="Czym jest Scikit-learn" href="tematy\files-regresja-liniowa-(i-nie-tylko)\czym-jest-scikit-learn.html" class="internal-link" target="_self" rel="noopener">Czym jest Scikit-learn?</a>
<br><a data-href="Implementacja regresji przy pomocy Scikit-learn" href="tematy\files-regresja-liniowa-(i-nie-tylko)\implementacja-regresji-przy-pomocy-scikit-learn.html" class="internal-link" target="_self" rel="noopener">Implementacja regresji przy pomocy Scikit-learn</a>
<br><br>Ćwiczenia dla tego tematu zostały zebrane <a data-tooltip-position="top" aria-label="https://github.com/" rel="noopener" class="external-link" href="https://github.com/" target="_blank">tutaj</a>.<br><br>Kliknij <a data-tooltip-position="top" aria-label="Index" data-href="Index" href="index.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej kursu.<br>* Podczas przygotowania opisów dla tego tematu, przy części zagadnień wykorzystane zostały narzędzia generatywnej sztucznej inteligencji.<br><br><br><br>
<br>
<br><a data-tooltip-position="top" aria-label="https://xkcd.com/1725" rel="noopener" class="external-link" href="https://xkcd.com/1725" target="_blank">https://xkcd.com/1725/</a><a href="about:blank#fnref-1-b5136e12ec7be2be" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
<br><a data-tooltip-position="top" aria-label="https://xkcd.com/605" rel="noopener" class="external-link" href="https://xkcd.com/605" target="_blank">https://xkcd.com/605/</a><a href="about:blank#fnref-2-b5136e12ec7be2be" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\regresja-liniowa-(i-nie-tylko).html</link><guid isPermaLink="false">Tematy/Regresja liniowa (i nie tylko).md</guid><pubDate>Fri, 11 Oct 2024 20:35:55 GMT</pubDate><enclosure url="tematy\images\linear_regression_meme.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="tematy\images\linear_regression_meme.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Cześć!]]></title><description><![CDATA[ 
 <br><br>Witaj na kursie wprowadzającym do uczenia maszynowego. Wybierz interesujący Cię temat z listy poniżej:<br><br><br><a data-tooltip-position="top" aria-label="https://github.com/dariak153" rel="noopener" class="external-link" href="https://github.com/dariak153" target="_blank">@dariak153</a><br>
<a data-tooltip-position="top" aria-label="https://github.com/mmcza" rel="noopener" class="external-link" href="https://github.com/mmcza" target="_blank">@mmcza</a>]]></description><link>index.html</link><guid isPermaLink="false">Index.md</guid><pubDate>Fri, 11 Oct 2024 19:42:19 GMT</pubDate></item><item><title><![CDATA[Czym jest Scikit-learn?]]></title><description><![CDATA[ 
 <br><br><br>Kliknij <a data-tooltip-position="top" aria-label="Regresja liniowa (i nie tylko)" data-href="Regresja liniowa (i nie tylko)" href="tematy\regresja-liniowa-(i-nie-tylko).html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu. Możesz stamtąd przejść do wykonania zadań przygotowanych w Jupyter Notebook.]]></description><link>tematy\files-regresja-liniowa-(i-nie-tylko)\implementacja-regresji-przy-pomocy-scikit-learn.html</link><guid isPermaLink="false">Tematy/Files Regresja liniowa (i nie tylko)/Implementacja regresji przy pomocy Scikit-learn.md</guid><pubDate>Sun, 06 Oct 2024 20:42:23 GMT</pubDate></item><item><title><![CDATA[Rodzaje regresji]]></title><description><![CDATA[ 
 <br><br>Istnieją różne rodzaje regresji, które różnią się rodzajem zależności między zmiennymi, które modelują. Najczęściej występujące to:<br>
<br>Regresja liniowa: Podstawowy rodzaj regresji, w którym założeniem jest liniowa zależność zmiennych (czyli można ją przedstawić za pomocą prostej), np. droga i czas w ruchu jednostajnym prostoliniowym,
<br>Regresja wielomianowa: Służy do modelowania bardziej złożonych zależności, których nie można opisać przy pomocy prostej, np. wzrost człowieka i wiek,
<br>Regresja logistyczna: Służy do przewidywania wartości binarnych (tak/nie, 0/1), np. czy stwierdzenie czy uda się przejechać drogę o danej długości bez tankowania,
<br>Regresja drzewiasta: Buduje model w postaci drzewa decyzyjnego, co pozwala na interpretację wyników, np. predykcja ceny domu, gdzie każdy węzeł jest pytaniem o jedną z cech (metraż, wiek, etc.).
<br>Aby łatwiej było zrozumieć różnice, poniżej znajdują się przykładowe wykresy z wrysowanymi poszczególnymi typami regresji<br><img alt="regression_types.png" src="lib\media\regression_types.png"><br>A na grafice poniżej widoczna jest wizualizacja drzewa decyzyjnego z przykładu powyżej, gdzie widać jak parametru x wpływa na wartość przewidywaną przez drzewo. Taki "schodkowy" przebieg regresji wynika z głębokości drzewa równej zaledwie max_depth=3, więc max 8 wartości na wyjściu.<br><img alt="decission_tree_regression_plot.png" src="lib\media\decission_tree_regression_plot.png"><br><br>Przejdź do kolejnego zagadnienia (<a data-href="Implementacja regresji przy pomocy Scikit-learn" href="tematy\files-regresja-liniowa-(i-nie-tylko)\implementacja-regresji-przy-pomocy-scikit-learn.html" class="internal-link" target="_self" rel="noopener">Implementacja regresji przy pomocy Scikit-learn</a>) lub kliknij <a data-tooltip-position="top" aria-label="Regresja liniowa (i nie tylko)" data-href="Regresja liniowa (i nie tylko)" href="tematy\regresja-liniowa-(i-nie-tylko).html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.]]></description><link>tematy\files-regresja-liniowa-(i-nie-tylko)\rodzaje-regresji.html</link><guid isPermaLink="false">Tematy/Files Regresja liniowa (i nie tylko)/Rodzaje regresji.md</guid><pubDate>Sun, 06 Oct 2024 20:55:06 GMT</pubDate><enclosure url="lib\media\regression_types.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\regression_types.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Funkcje w języku Python]]></title><description><![CDATA[ 
 <br><br>Funkcje w Pythonie umożliwiają podzielenie kodu na moduły, które można ponownie wykorzystywać. Tworzy się je za pomocą instrukcji def i ciała funkcji jak w poniższym przykładzie:<br>def nazwa_funkcji(argumenty):
	# tutaj co w funkcji się dzieje
	return wynik
Copy<br>gdzie:<br>
<br>def - słowo kluczowe inicjujące definicję funkcji,
<br>nazwa_funkcji - unikalna nazwa funkcji,
<br>argumenty - opcjonalna lista argumentów, które funkcja przyjmuje (można opcjonalnie zdefiniować typ i wartość domyślną elementów),
<br>return - opcjonalne słowo kluczowe, zwracające wartość z funkcji;<br>
a wywołanie funkcji wygląda następująco:
<br># W przypadku funkcji zwracającej wartość
zmienna = nazwa_funkcji(argumenty)

# W przypadku funkcji, która nic nie zwraca (np. ma wyświetlić w konsoli odpowiedź, ale nie zwrócić wyniku)
nazwa_funkcji(argumenty)
Copy<br>Przykłady tworzenia funkcji:<br>def oblicz_sume_kwadratow(x, y):
	result = x**2+y**2
	return result

# Przykład funkcji ze zdefiniowanymi typami danych dla argumentów i zwracanej wartości
def oblicz_kwadrat_sumy(x: float, y: float) -&gt;float:
	return (x+y)**2

# Przykład funkcji z wartością domyślną elementu
def oblicz_roznice_kwadratow(x, y=0.0):
	return x**2 - y**2

# Przykład funkcji z docstrings ("dokumentacją" funkcji)
def oblicz_kwadrat_roznicy(x, y):
  """Oblicza kwadrat różnicy dwóch liczb.

  Args:
    x: Pierwsza liczba.
    y: Druga liczba.

  Returns:
    Kwadrat różnicy liczb x i y.
  """
  return (x-y)**2
Copy<br>Możliwe jest też zwracanie więcej niż 1 wartości, np:<br>import datetime

def pobierz_aktualna_date():
  """Zwraca aktualną datę w postaci roku, miesiąca i dnia."""
  dzisiaj = datetime.date.today()
  return dzisiaj.year, dzisiaj.month, dzisiaj.day

# Wywołanie funkcji i przypisanie zwróconych wartości do zmiennych
rok, miesiac, dzien = pobierz_aktualna_date()

print(f"Dzisiaj jest {dzien} {miesiac} {rok}.")
Copy<br><br>Klasy są podstawowym elementem programowania obiektowego w Pythonie. Służą one do reprezentacji obiektów/pojęć w świecie rzeczywistym. Definicja klasy wygląda następująco:<br>class NazwaKlasy:
    def __init__(self, argumenty_init):
	    self.atrybuty_do_inicjalizacji = argumenty_init
	def metoda(self, argument_metody):
		self.atrybuty_do_modyfikacji = argumenty_metody
Copy<br>gdzie:<br>
<br>class - słowo kluczowe inicjujące definicję klasy,
<br>NazwaKlasy - unikalna nazwa klasy,
<br>atrybuty - zmienne związane z obiektami tej klasy (np. kolor, rozmiar),
<br>metody - funkcje związane z obiektami tej klasy (np. poruszanie się, rysowanie).<br>
a utworzenie obiektu danej funkcji wygląda następująco:
<br>zmienna = NazwaKlasy(argumenty)
Copy<br>Przykład tworzenia klasy:<br>class Pies:
    def __init__(self, imie, rasa):  
    # wewnątrz init inicjalizujemy wszystkie atrybuty klasy
        self.imie = imie
        self.rasa = rasa
        self.szczek = "Chał chał!"

	def zmien_imie(self, dzwiek):
		self.szczek = dzwiek

    def szczekaj(self):
        print(self.szczek)

moj_pies = Pies("Reksio", "Jamnik")
moj_pies.szczekaj()
# Dostęp do imienia psa
print(moj_pies.imie)
Copy<br>Python nie ma mechanizmu ścisłej prywatności artybutów tak jak np. C++, ale wykorzystanie __ na początku nazwy pozwala na oznaczenie artybutu jako prywatny, do którego należy odwoływać się przez metodę danej klasy:<br>class Osoba:
    def __init__(self, imie, pesel):
        self.imie = imie
        self.__pesel = pesel  # Prywatny atrybut

    def pobierz_pesel(self):
        return self.__pesel
Copy<br><img alt="PythonFruitClass.png" src="lib\media\pythonfruitclass.png"><br>
Źródło: <a data-footref="meme1" href="about:blank#fn-1-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[1]</a><br><br>Przejdź do kolejnego zagadnienia (<a data-href="Używanie bibliotek" href="tematy\files-wstęp-do-języka-python\używanie-bibliotek.html" class="internal-link" target="_self" rel="noopener">Używanie bibliotek</a>) lub kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.<br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://programmerhumor.io/python-memes/python-is-easy-they-say/" target="_blank">https://programmerhumor.io/python-memes/python-is-easy-they-say/</a><a href="about:blank#fnref-1-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\files-wstęp-do-języka-python\funkcje-i-klasy.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Funkcje i klasy.md</guid><pubDate>Sun, 06 Oct 2024 20:42:32 GMT</pubDate><enclosure url="lib\media\pythonfruitclass.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\pythonfruitclass.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Struktury danych w Python]]></title><description><![CDATA[ 
 <br><br>W Pythonie możemy wyróżnić następujące struktury danych: listy, krotki, zbiory i słowniki.<br>
<br>
Listy są najbardziej uniwersalnymi strukturami danych w Pythonie. Są to uporządkowane, mutowalne kolekcje, które mogą zawierać dowolne elementy. Możesz dodawać, usuwać i modyfikować elementy listy.

<br>
Tuple (krotki) są podobne do list, ale są niemutowalne, czyli po utworzeniu nie można zmieniać ich elementów. Są często używane do przechowywania danych, które nie powinny być modyfikowane.

<br>
Sety (zbiory) są nieuporządkowanymi zbiorami unikalnych elementów. Nie mogą zawierać duplikatów. Sety są używane do sprawdzania przynależności elementów, wykonywania operacji zbiorów (np. przecięcia, sumy) oraz usuwania duplikatów z sekwencji.

<br>
Słowniki to struktury danych, które przechowują pary klucz-wartość. Każdy klucz musi być unikalny. Słowniki są używane do szybkiego wyszukiwania wartości na podstawie klucza.

<br><br># List
numbers_list = [1, 2, 3, 4, 2]
mixed_list = [1, "hello", 3.14, True]

# Tuple
numbers_tuple = (1, 2, 3, 4, 2)
mixed_tuple = (1, "hello", 3.14, True)

# Set
numbers_set = {1, 2, 3, 4, 2}   # Przechowa jedynie unikalne wartosci {1,2,3,4} 
mixed_set = {1, "hello", 3.14, True}

# Dictionary
num_as_key = {25: "John", 30: "Jane"}
str_as_key = {"name": "Alice", "age": 28, "city": "London"}
Copy<br><br><br># Tworzenie listy
fruits = ["apple", "banana", "cherry"]

# Dodawanie elementu na koniec
fruits.append("orange")
print(fruits)  # Wynik: ['apple', 'banana', 'cherry', 'orange']

# Wstawianie elementu na określone miejsce
fruits.insert(1, "grape")
print(fruits)  # Wynik: ['apple', 'grape', 'banana', 'cherry', 'orange']

# Usuwanie elementu po wartości
fruits.remove("banana")
print(fruits)  # Wynik: ['apple', 'grape', 'cherry', 'orange']

# Usuwanie elementu po indeksie
del fruits[2]
print(fruits)  # Wynik: ['apple', 'grape', 'orange']

# Dostęp do elementu
print(fruits[0])  # Wynik: apple

# Długość listy
print(len(fruits))  # Wynik: 3

# Sortowanie listy
fruits.sort()
print(fruits)  # Wynik: ['apple', 'grape', 'orange'] (sortowanie alfabetyczne)
Copy<br><br>Krotki są niemutowalne, więc nie można dodawać ani usuwać elementów po ich utworzeniu!!! Aby zrobić zmiany można skopiować wartości z już istniejącej tupli do nowej.<br># Tworzenie tuple
numbers = (1, 2, 3)

# Dostęp do elementu
print(numbers[1])  # Wynik: 2

# Długość tuple
print(len(numbers))  # Wynik: 3
Copy<br><br># Tworzenie setu
my_set = {1, 2, 3, 2}  # Duplikaty są usuwane

# Dodawanie elementu
my_set.add(4)
print(my_set)  # Wynik: {1, 2, 3, 4}

# Usuwanie elementu
my_set.remove(2)
print(my_set)  # Wynik: {1, 3, 4}

# Długość setu
print(len(my_set))  # Wynik: 3

# Operacje na zbiorach (przecięcie, suma, różnica)
set1 = {1, 2, 3}
set2 = {2, 3, 4}
print(set1.union(set2))  # Suma zbiorów: {1, 2, 3, 4}
print(set1.intersection(set2))  # Przecięcie zbiorów: {2, 3}
Copy<br><br># Tworzenie słownika
person = {"name": "John", "age": 30, "city": "New York"}

# Dodawanie pary klucz-wartość
person["country"] = "USA"
print(person)

# Usuwanie pary klucz-wartość
del person["age"]
print(person)

# Dostęp do wartości
print(person["name"])  # Wynik: John

# Długość słownika (liczba par klucz-wartość)
print(len(person))  # Wynik: 2

# Sprawdzenie, czy klucz istnieje
if "city" in person:
    print("Klucz 'city' istnieje")
Copy<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Pętle i instrukcje warunkowe" href="tematy\files-wstęp-do-języka-python\pętle-i-instrukcje-warunkowe.html" class="internal-link" target="_self" rel="noopener">Pętle i instrukcje warunkowe</a>) lub kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.]]></description><link>tematy\files-wstęp-do-języka-python\listy,-krotki,-zbiory-i-słowniki.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Listy, krotki, zbiory i słowniki.md</guid><pubDate>Sun, 06 Oct 2024 20:42:39 GMT</pubDate></item><item><title><![CDATA[Pętle w języku Python]]></title><description><![CDATA[ 
 <br><br>Pętle w Pythonie służą do wielokrotnego wykonywania bloku kodu, tak długo jak dany warunek jest spełniony. Są wykorzystywane przy powtarzalnych zadaniach. Python oferuje dwa główne typy pętli: for i while.<br>W obu pętlach możliwe jest wykorzystanie dodatkowych funkcji:<br>
<br>break - przerwanie wykonania pętli,
<br>continue - przejście do następnej iteracji pętli (dalsza część obecnej iteracji się nie wykona).
<br><br>Pętla while wykonuje się tak długo, jak długo określony warunek jest prawdziwy.<br>count = 0
while count &lt; 5:
    print(count)
    count += 1
Copy<br><br>Pętla for służy do iterowania po sekwencjach:<br># Iterowanie po zakresie liczb
for i in range(5):
    print(i)

# Iterowanie po liście
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
Copy<br>Możliwe jest również wykorzystanie funkcji enumerate(zmienna), aby podczas iterowania po sekwencji mieć również informację o indeksie elementu:<br>fruits = ["apple", "banana", "cherry"]

for index, fruit in enumerate(fruits):
    print(f"Owoc na pozycji {index}: {fruit}")


# enumerate można też wykorzystać do utworzenia słownika
my_dict = dict(enumerate(fruits)) 
print(my_dict) # Wynik: {0: 'apple', 1: 'banana', 2: 'cherry'}
Copy<br><br>Za pomocą pętli w Pythonie można w bardzo zwięzły i czytelny sposób tworzyć lub modyfikować listy:<br># Przykład 1
numbers = [1, 2, 3, 4, 5] 
squares = [x**2 for x in numbers] 
print(squares) # Wynik: [1, 4, 9, 16, 25]

# Przykład 2
words = ["apple", "banana", "cherry", "eagle"]
vowels = "aeiou" 
filtered_words = [word for word in words if word[0] in vowels] print(filtered_words) # Wynik: ['apple', 'eagle']

# `for word in words`: Iteruje po każdym słowie w liście `words`.
# `if word[0] in vowels`: Sprawdza, czy pierwsza litera słowa jest samogłoską.
# Jeśli warunek jest spełniony, słowo jest dodawane do nowej listy `filtered_words`
Copy<br><br>Instrukcje warunkowe pozwalają na wykonanie określonych fragmentów kodu w zależności od spełnienia określonych warunków/kryteriów. Wyróżnić można następujące instrukcje:<br>
<br>if - podstawowy (pierwszy) warunek do sprawdzenia,
<br>elif - sprawdzenie kolejnego warunku, jeżeli poprzednie nie były spełnione,
<br>else - wykonanie w przypadku, gdy żaden wcześniejszy warunek nie został spełniony.
<br>Dostępne są następujące operatory porównania<br>
<br>== - równe,
<br>!= - różne,
<br>&lt; - mniejsze niż,
<br>&lt;= - mniejsze lub równe,
<br>&gt; - większe niż,
<br>&gt;= - większe lub równe;<br>
oraz następujące operatory logiczne
<br>and - oba warunki muszą być spełnione,
<br>or - przynajmniej jeden warunek musi być spełniony,
<br>not - negacja warunku.
<br>Przykłady:<br># Przykład 1
liczba = 10

if liczba &gt; 0:
    print("Liczba jest dodatnia.")
elif liczba &lt; 0:
    print("Liczba jest ujemna.")
else:
    print("Liczba jest równa zero.")


# Przykład 2
x = 10
y = 5

if x &gt; 5 and y &lt; 10:
	print("Oba warunki są spełnione.")
elif x &gt; 5 and not y &lt; 10:
	print("X jest wiekszy niz 5, a y nie jest wiekszy niz 10.")
Copy<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Funkcje i klasy" href="tematy\files-wstęp-do-języka-python\funkcje-i-klasy.html" class="internal-link" target="_self" rel="noopener">Funkcje i klasy</a>) lub kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.]]></description><link>tematy\files-wstęp-do-języka-python\pętle-i-instrukcje-warunkowe.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Pętle i instrukcje warunkowe.md</guid><pubDate>Sun, 06 Oct 2024 20:42:43 GMT</pubDate></item><item><title><![CDATA[Język interpretowany]]></title><description><![CDATA[ 
 <br><br>Python jest językiem interpretowanym, więc do korzystania z niego nie jest wymagany kompilator (wykorzystywany jest interpreter). Innymi przykładami tego typu języków są Bash, PHP lub JavaScript. Oznacza to, że skrypt jest przechowywany w formie kodu i interpretowany przy każdym uruchomieniu, a nie konwertowany na kod maszynowy jednorazowo <a data-footref="interp" href="about:blank#fn-1-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[1]</a>.<br><br><img alt="PythonWhere.png" src="lib\media\pythonwhere.png"><br>
Źródło: <a data-footref="meme2" href="about:blank#fn-2-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[2]</a><br>Tak jak na obrazku powyżej, programując w Pythonie na końcu linii nie stawia się średnika. Dla tych, którym w C++ się o tym zapomina, może być to ułatwienie, ale dla osób, które pisały "kilka linijek w jednej linijce" i oddzielały je średnikami to będzie wymagało przestawienia.<br>Na obrazku powyżej wspomniane były też klamry, bo ich też nie ma (więcej o tym jak wyglądają pętle i instrukcje warunkowe będzie dalej). Ale jeśli nie ma klamr, to skąd interpreter ma wiedzieć, które linie kodu są wewnątrz if'a, a które już poza? I tutaj przechodzimy do kolejnego obrazka...<br><img alt="NoIndent.png" src="lib\media\noindent.png"><br>
Źródło: <a data-footref="meme1" href="about:blank#fn-3-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[3]</a><br><br>Programując w C++ wcięcia zwiększają jedynie czytelność kodu dla programisty i można je pomijać. W przypadku Pythona wcięcia muszą być identyczne, żeby interpreter dobrze przetworzył kod. Wydaje mi się, że najlepiej jest to pokazać na przykładzie, więc taki znajduje się poniżej.<br>for i in range(3): 
	for j in range(3):
		result = i*10+j
		print(result)
	print("Wykonam się po skończeniu się pętli z j")
print("Wykonam się po skończeniu się pętli z i")
Copy<br>Nie wchodzimy na razie w szczegóły pętli i jak działa in range, ale wynikiem byłoby:<br>0
1
2
Wykonam się po skończeniu się pętli z j
10
11
12
Wykonam się po skończeniu się pętli z j
20
21
22
Wykonam się po skończeniu się pętli z j
Wykonam się po skończeniu się pętli z i
Copy<br>Czyli jak widać wpierw w pętli wewnętrznej (z podwójnym wcięciem) jest dodawanie, a następnie wypisywanie w konsoli wyniku. Po wykonaniu się pętli wewnętrznej, w konsoli pojawia się odpowiednia wiadomość (zwrócę uwagę, że for j in range(3): i print("Wykonam się po skończeniu się pętli z j")również mają identyczne wcięcia, bo są wewnątrz pętli ze zmienną i). Gdy pętla zewnętrzna wykona się odpowiednią ilość razy to w konsoli również pojawia się odpowiednia wiadomość.<br>W przykładzie użyłem tabulatora do robienia wcięć, ale równie dobrze można używać spacji - jedynie wcięcie musi mieć zawsze równą wielkość!<br><br>W Pythonie komentarze dodaje się po #, np:<br># Ta linia to komentarz
print("Hello world!") # A tu komentarz w linii z kodem
Copy<br>Możliwe są również komentarze wieloliniowe poprzez umieszczenie ich wewnątrz ``` ```. Ten drugi jest przydatny np. do przygotowania opisu funkcji, gdzie można w ten sposób opisać czym jest każda zmienna.<br><br>Przejdź do kolejnego zagadnienia (<a data-href="Zmienne i podstawowe typy danych" href="tematy\files-wstęp-do-języka-python\zmienne-i-podstawowe-typy-danych.html" class="internal-link" target="_self" rel="noopener">Zmienne i podstawowe typy danych</a>) lub kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.<br><br><br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" target="_blank">https://en.wikipedia.org/wiki/Interpreter_(computing)</a><a href="about:blank#fnref-1-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
<br><a rel="noopener" class="external-link" href="https://programmerhumor.io/python-memes/after-using-only-c-and-c-for-years-python-felt-kinda-strange/" target="_blank">https://programmerhumor.io/python-memes/after-using-only-c-and-c-for-years-python-felt-kinda-strange/</a><a href="about:blank#fnref-2-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
<br><a rel="noopener" class="external-link" href="https://programmerhumor.io/programming-memes/no-offence-python-from-one-python-lover-to-others/" target="_blank">https://programmerhumor.io/programming-memes/no-offence-python-from-one-python-lover-to-others/</a><a href="about:blank#fnref-3-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\files-wstęp-do-języka-python\składnia-w-języku-python.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Składnia w języku Python.md</guid><pubDate>Sun, 06 Oct 2024 20:42:48 GMT</pubDate><enclosure url="lib\media\pythonwhere.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\pythonwhere.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Po co używać biblioteki?]]></title><description><![CDATA[ 
 <br><br>Jeżeli będziemy pracowali nad jakimś projektem związanym z ... w sumie praktycznie z czymkolwiek to jest duże prawdopodobieństwo, że ktoś już coś podobnego robił i potrzebował do tego przygotować sobie narzędzia (funkcje, klasy) i stworzył z ich wykorzystaniem bibliotekę, więc możemy ją pobrać i korzystać z tego co ktoś przygotował i zaoszczędzić przy tym czas. Wg <a data-footref="mgl" href="about:blank#fn-1-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[1]</a> istnieje ponad 137.000 bibliotek, ale spokojnie, my będziemy korzystać z kilkunastu (być może kilkudziesięciu, ale to pojedyncze funkcje będą). To jak dużo jest bibliotek dobrze jest widoczne na zrzucie ekranu poniżej.<br><img alt="Libraries_in_python.png" src="lib\media\libraries_in_python.png"><br><br>Instalowanie bibliotek odbywa się z wykorzystaniem pip. Najlepiej odszukać w internecie nazwę interesującej nas biblioteki (bo nie zawsze nazwa przy importowaniu jest jednakowa jak przy instalacji), a następnie w konsoli użyć komendy:<br>pip install nazwa_biblioteki
Copy<br>W przypadku instalowania wielu bibliotek można to zrobić następująco:<br>pip install nazwa_biblioteki1 nazwa_biblioteki2
Copy<br>Czasami może być konieczność zainstalowania konkretnej wersji biblioteki (np. aby była kompatybilna z inną biblioteką). Należy wówczas użyć:<br>pip install nazwa_biblioteki==wersja
Copy<br>lub kombinacji &gt;, &lt;, &gt;= lub &lt;=, np.<br>pip install numpy&lt;=1.25.2
Copy<br>lub<br>pip install "numpy&gt;1.18.5,&lt;=1.25.2"
Copy<br>Dobrym zwyczajem jest również tworzenie pliku requirements.txt, w którym wypisane są wszystkie wykorzystywane biblioteki (jest to zwykły plik tekstowy, który można zrobić nawet w notatniku). Pozwoli to każdemu komu wyślemy kod na zainstalowanie tych samych bibliotek i tym samym uruchomienie skryptu (bez zainstalowania niestety nie pójdzie). Po utworzeniu pliku requirements.txt można łatwo całość zainstalować poleceniem<br>pip install -r requirements.txt
Copy<br><br>Po zainstalowaniu biblioteki, jej zaimportowanie jest proste. Wystarczy w skrypcie wpisać<br>import nazwa_biblioteki
Copy<br>Możliwe jest również nadanie aliasu (np. jeżeli biblioteka ma długą nazwę) lub zaimportowanie jedynie pewnych składników<br>import nazwa_biblioteki as alias_bibl # Importowanie z aliasem

from nazwa_biblioteki import funkcja, klasa # Importowanie wybranych składników
Copy<br>Tip
Należy zwrócić uwagę na to w jaki sposób importujemy bibliotekę, bo ma to wpływ na dalszy kod (np. po nadaniu aliasu nie możemy odwołać się do biblioteki pod jej standardową nazwą)
<br>Korzystanie z funkcji jest również stosunkowo proste. Załóżmy, że w bilioteka są funkcje funkcja1 i funkcja2. Poniżej znajduje się przykład z wszystkimi przedstawionymi powyżej możliwościami importu<br>import os # Importowanie biblioteki
import numpy as np # Importowanie biblioteki z aliasem
from pandas import DataFrame, read_csv # Importowanie tylko klasy i funkcji

# Utworzenie DataFrame z biblioteki Pandas przez wczytanie danych z pliku txt
data_frame = read_csv(os.path.join("/path/to/","filename.csv"))
# Konwersja na numpy array (to_numpy() jest metodą DataFrame)
array = data_frame.to_numpy()

# Obliczenie sumy wszystkich elementów wektora
array_sum = np.sum(array)
Copy<br><br>Kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu. Możesz stamtąd przejść do wykonania zadań przygotowanych w Jupyter Notebook.<br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://www.mygreatlearning.com/blog/open-source-python-libraries/" target="_blank">https://www.mygreatlearning.com/blog/open-source-python-libraries/</a><a href="about:blank#fnref-1-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\files-wstęp-do-języka-python\używanie-bibliotek.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Używanie bibliotek.md</guid><pubDate>Sun, 06 Oct 2024 20:42:52 GMT</pubDate><enclosure url="lib\media\libraries_in_python.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\libraries_in_python.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Podstawowe typy danych w języku Python]]></title><description><![CDATA[ 
 <br><br>Typ danych określa rodzaj informacji, którą możemy przechowywać w zmiennej. Python jest językiem dynamicznie typowanym, co oznacza, że nie musimy jawnie deklarować typu zmiennej przed jej użyciem. Interpreter automatycznie rozpoznaje typ na podstawie przypisanej wartości.<br><br>Przykłady tworzenia zmiennych poszczególnych typów (do przypisania służy =):<br>i = 37       # int
f = 92.13    # float
s = "Hello!" # string
b = True     # bool
Copy<br>Do sprawdzania typu zmiennej służy funkcja type(zmienna):<br>a = 13.23
print(type(a)) # &lt;class 'float'&gt;
Copy<br>Ze względu na dynamiczne typowanie, w Pythonie możliwe jest nadpisywanie typu danych, np:<br>x = 5.93
x = "Hello"
Copy<br>Możliwa jest również konwersja typów przy pomocy funkcji int(zmienna), float(zmienna) lub str(zmienna):<br>num = 927.27
num_as_str = str(num)
print(num_as_str)      # "927.27"
Copy<br><img alt="PythonDataTypes.png" src="lib\media\pythondatatypes.png"><br>
Źródło: <a data-footref="meme1" href="about:blank#fn-1-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[1]</a><br><br><br>W języku Python dostępne są następujące operatory arytmetyczne do zmiennych liczbowych.<br><br>Możliwe jest również wykorzystanie skróconych przypisań, co jest przydatne przy zmianie wartości, a służą do tego +=, -=, *=, /=, %=, **=.<br><br>Dla ciągów znaków nie można bezpośrednio zastosować tych samych operatorów arytmetycznych. Konieczna jest wpierw konwersja stringa na liczbę przy użyciu int(zmienna) lub float(zmienna). Stringi są niemutowalne, więc nie można zmienić pojedynczych znaków, a trzeba utworzyć nowy string.<br>Funkcje/operatory dostępne do wykorzystania ze stringami:<br><br><br>Przejdź do kolejnego zagadnienia (<a data-href="Listy, krotki, zbiory i słowniki" href="tematy\files-wstęp-do-języka-python\listy,-krotki,-zbiory-i-słowniki.html" class="internal-link" target="_self" rel="noopener">Listy, krotki, zbiory i słowniki</a>) lub kliknij <a data-tooltip-position="top" aria-label="Wstęp do języka Python" data-href="Wstęp do języka Python" href="tematy\wstęp-do-języka-python.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej tematu.<br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://programmerhumor.io/python-memes/im-a-python-programmer-2/" target="_blank">https://programmerhumor.io/python-memes/im-a-python-programmer-2/</a><a href="about:blank#fnref-1-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\files-wstęp-do-języka-python\zmienne-i-podstawowe-typy-danych.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Zmienne i podstawowe typy danych.md</guid><pubDate>Sun, 06 Oct 2024 20:43:09 GMT</pubDate><enclosure url="lib\media\pythondatatypes.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\pythondatatypes.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Wstęp do języka Python]]></title><description><![CDATA[ 
 <br>Pierwszym tematem kursu będzie krótki wstęp do programowania w Pythonie, bo będzie to język, który będziemy wykorzystywać w zadaniach i projekcie końcowym. Konkretnie powiemy tu o wersji Python 3.<br>Python jest szeroko wykorzystywany w uczeniu maszynowym, analizie danych, przy obliczeniach matematycznych, aplikacjach webowych po stronie serwera oraz do szybkiego prototypowania. Można go wykorzystać na różnych systemach, nie wymaga kompilatora, a jego składnia jest stosunkowo prosta i przypomina język angielski <a data-footref="w3s" href="about:blank#fn-1-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[1]</a>.<br>
<img alt="WhoWantsToBeDataScientist.png" src="tematy\images\whowantstobedatascientist.png"><br>
Źródło: <a data-footref="dsm" href="about:blank#fn-2-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[2]</a><br>W celu uproszczenia pracy, zadania będą przygotowane w formie Jupyter Notebooks, które możecie wstawić w celu uruchomienia np. na <a data-tooltip-position="top" aria-label="https://colab.research.google.com/" rel="noopener" class="external-link" href="https://colab.research.google.com/" target="_blank">Google Colab</a> lub <a data-tooltip-position="top" aria-label="https://www.kaggle.com/" rel="noopener" class="external-link" href="https://www.kaggle.com/" target="_blank">Kaggle</a> lub uruchomić lokalnie np. przy wykorzystaniu <a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener" class="external-link" href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a>. Jak chodzi o programowanie w Pythonie (bez Notebooków) to mogę polecić korzystanie z <a data-tooltip-position="top" aria-label="https://www.jetbrains.com/pycharm/" rel="noopener" class="external-link" href="https://www.jetbrains.com/pycharm/" target="_blank">PyCharm'a</a>.<br>
<img alt="Jupyter-logo.svg" src="tematy\images\jupyter-logo.svg" style="width: 350px; max-width: 100%;"><br>
Źródło: <a data-footref="jpt" href="about:blank#fn-3-581235665ae94e81" class="footnote-link" target="_self" rel="noopener">[3]</a><br><br>
<br><a data-href="Jak korzystać z Jupyter Notebooks" href="tematy\files-wstęp-do-języka-python\jak-korzystać-z-jupyter-notebooks.html" class="internal-link" target="_self" rel="noopener">Jak korzystać z Jupyter Notebooks</a>
<br><a data-href="Składnia w języku Python" href="tematy\files-wstęp-do-języka-python\składnia-w-języku-python.html" class="internal-link" target="_self" rel="noopener">Składnia w języku Python</a>
<br><a data-href="Zmienne i podstawowe typy danych" href="tematy\files-wstęp-do-języka-python\zmienne-i-podstawowe-typy-danych.html" class="internal-link" target="_self" rel="noopener">Zmienne i podstawowe typy danych</a>
<br><a data-href="Listy, krotki, zbiory i słowniki" href="tematy\files-wstęp-do-języka-python\listy,-krotki,-zbiory-i-słowniki.html" class="internal-link" target="_self" rel="noopener">Listy, krotki, zbiory i słowniki</a>
<br><a data-href="Pętle i instrukcje warunkowe" href="tematy\files-wstęp-do-języka-python\pętle-i-instrukcje-warunkowe.html" class="internal-link" target="_self" rel="noopener">Pętle i instrukcje warunkowe</a>
<br><a data-href="Funkcje i klasy" href="tematy\files-wstęp-do-języka-python\funkcje-i-klasy.html" class="internal-link" target="_self" rel="noopener">Funkcje i klasy</a>
<br><a data-href="Używanie bibliotek" href="tematy\files-wstęp-do-języka-python\używanie-bibliotek.html" class="internal-link" target="_self" rel="noopener">Używanie bibliotek</a>
<br>Oczywiście nie są to wszystkie zagadnienia związane z Pythonem. Dostępnych jest wiele kursów, poradników i stron z informacjami i ćwiczeniami na ten temat. Przykładami mogą być <a data-tooltip-position="top" aria-label="https://www.w3schools.com/python/default.asp" rel="noopener" class="external-link" href="https://www.w3schools.com/python/default.asp" target="_blank">w3schools</a> i <a data-tooltip-position="top" aria-label="https://www.kaggle.com/learn/python" rel="noopener" class="external-link" href="https://www.kaggle.com/learn/python" target="_blank">kaggle</a>.<br><br>Ćwiczenia dla tego tematu zostały zebrane <a data-tooltip-position="top" aria-label="https://github.com/" rel="noopener" class="external-link" href="https://github.com/" target="_blank">tutaj</a>.<br><br>Kliknij <a data-tooltip-position="top" aria-label="Index" data-href="Index" href="index.html" class="internal-link" target="_self" rel="noopener">tutaj</a>, aby wrócić do strony głównej kursu.<br>* Podczas przygotowania opisów dla tego tematu, przy części zagadnień wykorzystane zostały narzędzia generatywnej sztucznej inteligencji.<br><br><br><br><br>
<br>
<br><a rel="noopener" class="external-link" href="https://www.w3schools.com/python/python_intro.asp" target="_blank">https://www.w3schools.com/python/python_intro.asp</a><a href="about:blank#fnref-1-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
<br><a rel="noopener" class="external-link" href="https://programmerhumor.io/python-memes/python-10/" target="_blank">https://programmerhumor.io/python-memes/python-10/</a><a href="about:blank#fnref-2-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
<br><a rel="noopener" class="external-link" href="https://www.jetbrains.com/pycharm/" target="_blank">https://www.jetbrains.com/pycharm/</a><a href="about:blank#fnref-3-581235665ae94e81" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>tematy\wstęp-do-języka-python.html</link><guid isPermaLink="false">Tematy/Wstęp do języka Python.md</guid><pubDate>Sun, 06 Oct 2024 20:38:57 GMT</pubDate><enclosure url="tematy\images\whowantstobedatascientist.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="tematy\images\whowantstobedatascientist.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Wizualizacja danych za pomocą bibliotek Matplotlib, Seaborn i Plotly w Pytonie]]></title><description><![CDATA[ 
 <br><img alt="datavis.png" src="tematy\images\datavis.png"><br>Omówienie najpopularniejszych bibliotek do wizualizacji danych:<br><br>Szczegółowe dokumentacje:<br>
<br><a data-tooltip-position="top" aria-label="https://matplotlib.org/stable/contents.html" rel="noopener" class="external-link" href="https://matplotlib.org/stable/contents.html" target="_blank">Matplotlib Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://seaborn.pydata.org/" rel="noopener" class="external-link" href="https://seaborn.pydata.org/" target="_blank">Seaborn Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://plotly.com/python/" rel="noopener" class="external-link" href="https://plotly.com/python/" target="_blank">Plotly Documentation</a>
<br>Przykładowy wykres przy pomocy biblioteki matplotlib:<br>import matplotlib.pyplot as plt
import pandas as pd


data = {
    'Miesiąc': ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'],
    'Przychody (tys. USD)': [9500, 9800, 10200, 10300, 11000, 11500, 12000, 12500, 11500, 11000, 10500, 9900]
}

df = pd.DataFrame(data)

plt.figure(figsize=(12, 6))
plt.plot(df['Miesiąc'], df['Przychody (tys. USD)'], marker='o', linestyle='-', color='teal')
plt.title('Miesięczne przychody spółki w 2023 roku')
plt.xlabel('Miesiąc')
plt.ylabel('Przychody (tys. USD)')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()


Copy<br><br>
Przykładowy wykres słupkowy przy pomocy biblioteki seaborn:<br>import seaborn as sns 
import pandas as pd

data = { 
		'Miasto': ['Warszawa', 'Kraków', 'Gdańsk', 'Wrocław', 'Poznań', 'Szczecin', 'Olsztyn'], 
	    'Cena': [800, 750, 700, 680, 650, 620, 570, 490] 
	    }
	    
df = pd.DataFrame(data)

sns.barplot(x='Miasto', y='Cena', data=df, palette='viridis') 
plt.title('Cena mieszkań w różnych miastach') 
plt.xlabel('Miasto')
plt.ylabel('Cena mieszkania (w tys. PLN)') 
plt.show()


Copy<br>Przykładowy wykres kołowy przy pomocy biblioteki seaborn:<br>import seaborn as sns  
import pandas as pd  
import matplotlib.pyplot as plt  
  
  
data = {  
    'Kategoria': ['Narzędzia', 'Oświetlenie', 'Farby i lakiery', 'Ogrodnictwo', 'Meble'],  
    'Udział': [30, 20, 25, 15, 10]  
}  
  
df = pd.DataFrame(data)  
  
plt.figure(figsize=(8, 8))  
plt.pie(df['Udział'], labels=df['Kategoria'], autopct='%1.1f%%', colors=sns.color_palette('Set1'))  
plt.title('Udział kategorii produktów w sprzedaży w sklepie OBI')  
plt.show()



Copy<br>Przykładowe wykresy przy pomocy biblioteki Plotly:<br># wykres kołowy 

import plotly.express as px  
import pandas as pd  

data = {  
    'Producent': ['Apple', 'Samsung', 'Huawei', 'Xiaomi', 'Oppo'],  
    'Udział': [40, 30, 15, 10, 5]  
}  
  
df = pd.DataFrame(data)  
  
fig = px.pie(df, values='Udział', names='Producent', title='Udział rynkowy producentów telefonów')  
fig.update_traces(textinfo='percent+label')  
fig.show()

Copy<br># wykres słupkowy  
import plotly.graph_objects as go  
import pandas as pd  
  

data = {  
    'Kraj': ['USA', 'Chiny', 'Japonia', 'Wielka Brytania', 'Australia'],  
    'Złote': [15, 12, 10, 8, 7],  
    'Srebrne': [10, 11, 9, 8, 6],  
    'Brązowe': [10, 7, 8, 6, 6]  
}  
  
df = pd.DataFrame(data)  
fig = go.Figure()  
  

fig.add_trace(go.Bar(  
    x=df['Kraj'],  
    y=df['Złote'],  
    name='Złote',  
    marker_color='gold'  
))  
  
fig.add_trace(go.Bar(  
    x=df['Kraj'],  
    y=df['Srebrne'],  
    name='Srebrne',  
    marker_color='silver'  
))  
  
fig.add_trace(go.Bar(  
    x=df['Kraj'],  
    y=df['Brązowe'],  
    name='Brązowe',  
    marker_color='#cd7f32'  
))  
   
fig.update_layout(  
    title='Liczba medali dla Top 5 Krajów na Igrzyskach Olimpijskich w Paryżu 2024',  
    xaxis_title='Kraj',  
    yaxis_title='Liczba Medali',  
    barmode='group',    
template='plotly_white'  
)  
  
fig.show()
Copy<br>
import plotly.graph_objects as go  
import pandas as pd  
  

data = {  
    'Data': ['2024-07-01', '2024-07-15', '2024-08-01', '2024-08-15', '2024-09-01'],  
    'Manchester City': [10, 12, 15, 18, 20],  
    'Real Madryt': [8, 10, 12, 14, 17],  
    'Bayern Monachium': [9, 11, 14, 16, 19],  
    'Paris Saint-Germain': [7, 9, 13, 15, 18],  
    'Liverpool': [6, 8, 11, 13, 16]  
}  
  
df = pd.DataFrame(data)  
df['Data'] = pd.to_datetime(df['Data'])  
  
  
fig = go.Figure()  
  
for team in df.columns[1:]:  
    fig.add_trace(go.Scatter(  
        x=df['Data'],  
        y=df[team],  
        mode='lines+markers',  
        name=team,  
        text=df[team],  
        textposition='top center'  
    ))  

fig.update_layout(  
    title='Zmiana punktacji Drużyn UEFA w ciągu kilku tygodni',  
    xaxis_title='Data',  
    yaxis_title='Punkty',  
    legend_title='Drużyna',  
    template='plotly_dark',  
    xaxis=dict(  
        tickformat='%Y-%m-%d',  
        tickvals=df['Data'],  
        ticktext=[date.strftime('%b %d') for date in df['Data']]  
    )  
)  
  
fig.show()
Copy]]></description><link>tematy\wizualizacja-danych-za-pomocą-bibliotek-matplotlib,-seaborn-i-plotly-w-pytonie.html</link><guid isPermaLink="false">Tematy/Wizualizacja danych za pomocą bibliotek Matplotlib, Seaborn i Plotly w Pytonie.md</guid><pubDate>Sat, 05 Oct 2024 17:28:54 GMT</pubDate><enclosure url="tematy\images\datavis.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="tematy\images\datavis.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Jak korzystać z Jupyter Notebooks]]></title><description><![CDATA[ 
 ]]></description><link>tematy\files-wstęp-do-języka-python\jak-korzystać-z-jupyter-notebooks.html</link><guid isPermaLink="false">Tematy/Files Wstęp do języka Python/Jak korzystać z Jupyter Notebooks.md</guid><pubDate>Mon, 12 Aug 2024 21:25:58 GMT</pubDate></item><item><title><![CDATA[Analiza danych przy pomocy Pandas i numpy]]></title><description><![CDATA[ 
 <br>Pandas to biblioteka w języku Python, stworzona z myślą o łatwiej i efektywnej analizie danych.<br>Pandas pozwala na szybkie, elastyczne i intuicyjne operacje na danych, zarówno jednowymiarowych (Series), jak i wielowymiarowych (DataFrame).<br> [Eksploracja Danych]<br>Możliwości biblioteki Pandas:<br>
<br>Wczytywanie i zapisywanie danych w różnych formatach:  CSV, Excel, JSON i SQL
<br>Przekształcanie i czyszczenie danych: 
<br>
<br>Usuwanie wybranych kolumn 
<br>Wyświetlanie i zliczanie unikalnych wartości w kolumnach 
<br>Usuwanie brakujących wartości 
<br>Uzupełnianie brakujących wartości
<br>
<br>Analiza statystyczna: 
<br>
<br>Wyświetlanie podstawowych statystyk opisowych
<br>Wyświetlanie liczby wierszy i kolumn DataFrame 
<br>Wyświetlanie typów danych w każdej kolumnie
<br>
<br>Wizualizacja danych: 
<br>
<br>Integracja z bibliotekami do wizualizacji danych (np. Matplotlib, Seaborn)
<br>Wczytywanie i zapis danych:<br>Wczytywanie danych z pliku  CSV:<br>   import pandas as pd 
   df = pd.read_csv('plik.csv')
Copy<br>Zapis danych jako pliku CSV:<br>   df.to_csv('nowy_plik.csv', index=False)
Copy<br>Wczytywanie danych z pliku Excel:<br>   df = pd.read_excel('plik.xlsx')
Copy<br>Wczytywanie danych z pliku JSON:<br>   df = pd.read_json('plik.json')
Copy<br>Podstawowe Operacje na DataFrame:<br>
<br>
Wyświetlanie ostatnich 5 wierszy:
print(df.tail()) 
Copy

<br>
Wyświetlanie informacji o DataFrame:
print(df.info()) 
Copy

<br>
Wyświetlanie podstawowych statystyk opisowych:

<br>print(df.describe())
Copy<br>
<br>Wyświetlanie liczby wierszy i kolumn Dataframe:
<br>print(df.shape)
Copy<br>
<br>Wyświetlanie typów danych w każdej kolumnie:
<br>print(df.dtypes)
Copy<br>
<br>Wyświetlanie kolumn:
<br>print(df.columns)
Copy<br>Przekształcanie, czyszczenie i transformacje danych: <br> Wyświetlanie i zliczanie unikalnych wartości w kolumnie :<br>print(df.['nazwa_kolumny'].unique())

print(df.['nazwa_kolumny'].value_counts())
Copy<br> Usuwanie wybranej kolumny:<br>df.drop(columns=['nazwa_kolumny'], inplace=True)
Copy<br>Wyświetlanie brakujących danych:<br>print(df.isnull().sum())
Copy<br>Usuwanie brakujących wartości<br>df.dropna(inplace=True)
Copy<br>Uzupełnianie brakujących wartości<br>df.fillna(0, inplace=True)
Copy<br>Filtrowanie wierszy, gdzie wartość w kolumnie 'wiek' jest większa niż 25:<br>df_filtered = df[df['wiek'] &gt; 25]
Copy<br>Filtrowanie wierszy, gdzie wartość w kolumnie 'wiek' jest większa niż 25 i w kolumnie 'miasto' jest równa 'Poznań':<br>df_filtered = df[(df['wiek'] &gt; 25) &amp; (df['miasto'] == 'Poznań')]
Copy<br>Grupowanie danych i obliczanie statystyk dla każdej grupy:<br>grouped = df.groupby('nazwa_kolumny').mean()
Copy<br>Sortowanie danych według wybranej kolumny:<br>df_sorted = df.sort_values(by='nazwa_kolumny', ascending=True)
Copy<br>Zmian nazw kolumn:<br>df.rename(columns={'stara_nazwa': 'nowa_nazwa'}, inplace=True)
Copy<br>Numpy to podstawowa biblioteka w języku Python, używana do obliczeń naukowych i analizy danych. Oferuje struktury danych, takie jak tablice wielowymiarowe (ndarray) i funkcje matematyczne.<br><br>
<br>Tworzenie i manipulowanie tablicami wielowymiarowymi:
<br>
<br>Tworzenie tablic z list, zakresów, plików 
<br>Operacje matematyczne na tablicach -
<br>Indeksowanie i wycinanie tablic
<br>Zmiana kształtu tablic 
<br>
<br>Funkcje matematyczne i statystyczne:
<br>
<br>Podstawowe operacje matematyczne (dodawanie, odejmowanie, mnożenie, dzielenie)
<br>Funkcje trygonometryczne 
<br>Funkcje statystyczne (średnia, mediana, odchylenie standardowe) 
<br>
<br>Algebra liniowa:
<br>
<br>Mnożenie macierzy 
<br>Wyznacznik macierzy
<br>Rozwiązywanie układów równań liniowych
<br>Wartości własne i wektory własne
<br>
<br>Generowanie liczb losowych z różnych rozkładów (normalny, jednostajny, itp.) 
<br>Wczytywanie i zapisywanie danych
<br>Tworzenie tablicy z samymi zerami:<br>a = np.zeros((3, 4)) # 3 wiersze, 4 kolumny
Copy<br><br>
Obliczanie średniej:<br>a = np.array([1, 2, 3, 4, 5])
mean = np.mean(a)
print(mean)
Copy]]></description><link>tematy\analiza-danych-przy-pomocy-pandas-i-numpy.html</link><guid isPermaLink="false">Tematy/Analiza danych przy pomocy Pandas i numpy.md</guid><pubDate>Mon, 12 Aug 2024 21:26:26 GMT</pubDate></item></channel></rss>